import React, { useEffect, useMemo, useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Input } from "@/components/ui/input";

const API = "http://127.0.0.1:8000";

type FileBlob = { path: string; contents: string };
type Finding = { path: string; notes: string[] };
type ReviewReply = { summary: string; findings: Finding[] };

export default function ReviewerPanel() {
  // Simple single-file inputs (quick use)
  const [path, setPath] = useState("reya-ui/src/components/Old.tsx");
  const [contents, setContents] = useState("// TODO: fix issue\nconsole.log('debug')");

  // Advanced: multi-file JSON (optional). If present, we use this instead of single-file inputs.
  const [filesJSON, setFilesJSON] = useState<string>("");

  const [status, setStatus] = useState<string>("");
  const [findings, setFindings] = useState<Finding[]>([]);
  const [summary, setSummary] = useState<string>("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Prefill from Coder ‚Üí Reviewer handoff (localStorage)
  useEffect(() => {
    let cancelled = false;
    try {
      const raw = localStorage.getItem("reviewer:prefill");
      if (raw) {
        const parsed = JSON.parse(raw);
        // Expect shape: { ticket?, files: FileBlob[], notes? }
        const files: FileBlob[] = parsed?.files || [];
        if (files.length) {
          // Load first file into quick editor + keep full JSON for batch mode
          if (!cancelled) {
            setFilesJSON(JSON.stringify(files, null, 2));
            setPath(files[0].path);
            setContents(files[0].contents);
            setStatus("Loaded Coder ‚Üí Reviewer handoff ‚úÖ");
          }
        }
        // We DO NOT remove here; Fixer will clear after consuming
      } else {
        setStatus("No incoming handoff detected.");
      }
    } catch {
      // ignore
    }
    return () => {
      cancelled = true;
    };
  }, []);

  function parseFiles(): FileBlob[] | null {
    // If advanced JSON present, prefer that
    if (filesJSON.trim()) {
      try {
        const arr = JSON.parse(filesJSON) as FileBlob[];
        if (!Array.isArray(arr) || arr.length === 0) {
          setError("Files JSON must be a non-empty array.");
          return null;
        }
        const ok = arr.every((f) => f && typeof f.path === "string" && typeof f.contents === "string");
        if (!ok) {
          setError("Each file must have { path: string, contents: string }.");
          return null;
        }
        return arr;
      } catch (e: any) {
        setError(`Files JSON parse error: ${e.message || e}`);
        return null;
      }
    }
    // Fallback to single-file mode
    if (!path.trim()) {
      setError("Provide a file path or Files JSON.");
      return null;
    }
    return [{ path, contents }];
  }

  async function runReview() {
    setError(null);
    setLoading(true);
    setFindings([]);
    setSummary("");
    setStatus("Reviewing‚Ä¶");

    const files = parseFiles();
    if (!files) {
      setLoading(false);
      setStatus("Fix input errors and retry.");
      return;
    }

    try {
      const res = await fetch(`${API}/roles/reviewer/review`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ files }),
      });
      const data: ReviewReply = await res.json();
      if (!res.ok) throw new Error((data as any)?.detail || "request failed");

      setFindings(data.findings || []);
      setSummary(data.summary || "");
      setStatus("Review complete ‚úÖ");
    } catch (e: any) {
      setError(e.message || "Review failed");
      setStatus("Review failed");
    } finally {
      setLoading(false);
    }
  }

  function sendToFixer() {
    const files = parseFiles();
    if (!files) {
      setError("Nothing to send: provide files first.");
      return;
    }
    // We forward findings as-is (Fixer accepts `findings` or `issues`)
    const payload = {
      files,
      findings, // [{ path, notes }]
      notes: summary || "Findings generated by Reviewer",
    };
    localStorage.setItem("reviewer:prefill", JSON.stringify(payload));
    setStatus("Sent to Fixer ‚úÖ");
    // Navigate to Fixer tab (adjust if you use a router)
    window.location.hash = "#/roles?tab=fixer";
  }

  const canSend = useMemo(() => {
    // Allow sending if we have files and either findings or at least a summary
    const haveFiles =
      (filesJSON.trim() && (() => { try { return Array.isArray(JSON.parse(filesJSON)); } catch { return false; } })()) ||
      !!path.trim();
    return haveFiles && (findings.length > 0 || !!summary);
  }, [filesJSON, path, findings.length, summary]);

  return (
    <Card className="ga-panel ga-outline">
      <CardContent className="space-y-3 p-4">
        <div className="flex items-center justify-between">
          <h2 className="font-semibold">Reviewer üîç</h2>
          <div className="flex gap-2">
            <Button variant="outline" disabled={!canSend} onClick={sendToFixer}>
              Send to Fixer
            </Button>
          </div>
        </div>

        {status && <div className="text-sm ga-subtle">{status}</div>}
        {error && <div className="text-sm text-red-600">{error}</div>}

        {/* Optional multi-file mode */}
        <label className="grid gap-1">
          <span className="text-sm font-medium">Files (JSON) ‚Äì optional</span>
          <Textarea
            className="min-h-32 font-mono text-sm"
            spellCheck={false}
            value={filesJSON}
            onChange={(e) => setFilesJSON(e.target.value)}
            placeholder='[{"path":"file.tsx","contents":"..."}]'
          />
        </label>

        <div className="text-xs ga-subtle">If JSON above is provided, it overrides the single-file inputs below.</div>

        {/* Single-file quick editor */}
        <Input value={path} onChange={(e) => setPath(e.target.value)} placeholder="File path" />
        <Textarea
          className="min-h-40 font-mono text-sm"
          spellCheck={false}
          value={contents}
          onChange={(e) => setContents(e.target.value)}
          placeholder="// paste code here"
        />

        <div className="flex gap-2">
          <Button className="ga-btn" disabled={loading} onClick={runReview}>
            {loading ? "Reviewing‚Ä¶" : "Run review"}
          </Button>
          <Button variant="outline" disabled={!canSend} onClick={sendToFixer}>
            Send to Fixer
          </Button>
        </div>

        {/* Results */}
        {summary && <div className="text-sm bg-zinc-100 text-zinc-800 rounded p-2">{summary}</div>}

        {!!findings.length && (
          <div className="space-y-2">
            <h3 className="text-lg font-semibold">Findings</h3>
            <div className="grid gap-2">
              {findings.map((f, i) => (
                <div key={i} className="border rounded p-2">
                  <div className="text-xs font-mono bg-zinc-100 text-zinc-700 px-2 py-1 rounded">{f.path}</div>
                  <ul className="list-disc pl-6 text-sm mt-1">
                    {f.notes.map((n, j) => (
                      <li key={j}>{n}</li>
                    ))}
                  </ul>
                </div>
              ))}
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
